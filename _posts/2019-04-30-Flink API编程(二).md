---
layout: post
title: Flink API编程（二）
tags: [flink]
---

## Flink API编程（事件时间和水印）
支持事件时间的流处理器需要一种方法来衡量事件时间的进度,比如按照10分钟构建的窗口，需要知道当事件时间超过10分钟后需要进行通知，是的算子可以结束本轮运算。Flink中，这个衡量事件时间进度的机制是Watermarks。
event time(事件时间)和Watermark(水印)是Flink的两个核心概念，是Flink 实现 乱序处理、窗口计算的基础。

### 1 事件时间和水印(Event time and WaterMarks)
#### 1.1 event time
Flink 支持三种类型的时间：
* `event time`:事件时间，流上的事件真是发生的时间
* `ingestion time`:摄入时间，流上的事件进入Flink时的时间
* `Processing time`:处理时间，Flink的算子在处理该事件的时间
大多数场景使用`event time`，因为即使应用挂掉或者failover，重新运算后的结果仍能保持一致。Flink默认使用Processing time，如果需要使用其他类型的时间，可以按照如下显示指定：

```
final StreamExecutionEnvironment env =
  StreamExecutionEnvironment.getExecutionEnvironment();
env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);

```
指定`event time`后，我们需要在代码里实现一个`时间提取器`(Timestamp Extractor)和`水印生成器`(Watermark Generator)，这样Flink才能实现对`event time`的跟踪处理 

#### 1.2 watermarks
通过一个简单的例子来说明我们为什么需要watermarks及其工作机制。例子中的流数据为带时间戳的事件，事件达到时是乱序的，流中的数字表示事件发生的时间，比如第一个到达的事件发生在t4时刻，第二个达到的事件发生在t2时刻，比第一个到达的时间早发生，完整的流如下：
```
··· 23 19 22 24 21 14 17 13 12 15 9 11 7 2 4 →
``` 
假设我们需对流中数据进行排序，这意味着我们的应用程序需要在流中的每个事件到达时进行处理，并将处理结果发送到一个新的有序（按照事件发生时间）的输出流。在实现过程中，我们会发现：
（1）进入排序算子的第一个元素(即事件)是`4`,但我们不能立即将这个元素发布到输出流。因为元素的到达时间是乱序的，更早发生的事件可能还未到达。事实上，我们以上帝视角会发现，排序算子至少需要等待元素`2`到达之后才能进行操作。

**总结：适当的缓存、适当的延迟是必须的**

（2）如果判断错误，那么程序可能永远等待。比如我们的应用程序第一个看到的元素`4`来了，接着`2`来了，那会不会有时间戳小于`2`呢？可能吧，如果这样考虑，我们只能永远等待，因为后续元素中没有`1`。

**总结：最终，我们必须勇敢将2作为排序流的开始元素**

（3）我们需要的是某种策略，定义对于任何给定的时间戳事件，何时停止等待更早发生的事件。

**总结：这就是水印所做的事情：水印定义了什么时候应该停止等待更早发生的事件。** 

   Flink实现`event time`处理是通过在`watermark generators`在流中插入特定时间戳的元素，这些元素称为水印。
   什么时候应该停止等待，并将`2`发送到输出流？当一个时间戳为`2`的或者有时间戳更大的水印到达时，就是停止等待并发送`2`的时机。

（4）我们可以思考下生成水印的不同策略。
   我们知道每一个事件的到达都有一定的延迟，这些延迟各不相同，一些事件的延迟比其他事件的延迟更大。一种简单的方法是假设这些延迟均包含于一些最大延迟构成的区间。Flink将这种策略称为有界无序水印(`bounded-out-of-orderness watermarking`)。
   虽然可以想象一些更复杂的生成水印的方法，但对于大多数应用程序来说，这种延迟为固定值水印的效果已经足够好了。

##### 1.3 Working with Watermarks


### 2 窗口(Windows)

### 3 Lab2 窗口练习